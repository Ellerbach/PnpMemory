//  <auto-generated/> 
using nanoFramework.Azure.Devices.Client;
using nanoFramework.Azure.Devices.Shared;
using nanoFramework.Json;
using nanoFramework.M2Mqtt.Messages;
using System;
using System.Collections;
using System.Security.Cryptography.X509Certificates;
using System.Threading;

namespace PnpMemory
{
    public class rido_pnp_memmon
    {
        #region Common

        public const string ModelId = "dtmi:rido:pnp:memmon;1";
        // 1 per command
        private CommandgetRuntimeStats _commandgetRuntimeStats;

        // for all the properties
        private DateTime _started;
        private bool _enabled;
        private TimeSpan _interval;

        // For the twin version
        private long _twinVersion;

        public DeviceClient AzureIoT { get; internal set; }

        public static rido_pnp_memmon CreateDevice(string iotName, string deviceName, string sasKey, MqttQoSLevel mqttQoSLevel = MqttQoSLevel.AtMostOnce, X509Certificate azureCert = null)
        {
            var client = new rido_pnp_memmon(iotName, deviceName, sasKey, mqttQoSLevel, azureCert);
            return client;
        }

        private rido_pnp_memmon(string iotName, string deviceName, string sasKey, MqttQoSLevel mqttQoSLevel, X509Certificate azureCert = null)
        {
            AzureIoT = new DeviceClient(iotName, deviceName, sasKey, mqttQoSLevel, azureCert, ModelId);
            AzureIoT.TwinUpated += AzureTwinUpdated;
            AzureIoT.AddMethodCallback(getRuntimeStats);
            var twin = AzureIoT.GetTwin(new CancellationTokenSource(5000).Token);
            // Force twin update
            AzureTwinUpdated(null, new TwinUpdateEventArgs(twin.Properties.Desired));
        }

        private void AzureTwinUpdated(object sender, TwinUpdateEventArgs e)
        {
            if (e.Twin.Contains("started"))
            {
                _started = (DateTime)e.Twin["started"];
            }

            if (e.Twin.Contains("enabled"))
            {
                _enabled = (bool)e.Twin["enabled"];
            }

            if (e.Twin.Contains("interval"))
            {
                // This won't work, need something to transform
                _interval = (TimeSpan)e.Twin["interval"];
            }

            _twinVersion = e.Twin.Version;
        }

        private string getRuntimeStats(int rid, string payload)
        {
            // Note: something to deserialize is needed, enums are a bit specific if passed as tring
            diagnosticsMode diagnosticsMode = GetdiagnosticsModeFromString(payload);
            if (_commandgetRuntimeStats != null)
            {
                var res = _commandgetRuntimeStats.Invoke(rid, diagnosticsMode);
                if (res != null)
                {
                    return JsonConvert.SerializeObject(res);
                }
            }

            return String.Empty;
        }

        // If the paylod is as a string, then for enums, this is needed
        private static diagnosticsMode GetdiagnosticsModeFromString(string str) => str switch
        {
            "minimal" => diagnosticsMode.minimal,
            "complete" => diagnosticsMode.complete,
            "full" => diagnosticsMode.full,
            _ => throw new ArgumentOutOfRangeException(nameof(str))
        };

        #endregion
        #region Properties

        public DateTime started { get => _started; }

        public bool enabled
        {
            get => _enabled;
            set
            {
                _enabled = value;
                PropertyAcknowledge targetReport = new() { Version = (int)_twinVersion, Status = PropertyStatus.Completed, Description = String.Empty, Value = _enabled };
                TwinCollection twin = new TwinCollection();
                twin.Add("enabled", targetReport.BuildAcknowledge());
                AzureIoT.UpdateReportedProperties(twin);
            }
        }

        public TimeSpan interval 
        {
            get => _interval;
            set
            {
                _interval = value;
                PropertyAcknowledge targetReport = new() { Version = (int)_twinVersion, Status = PropertyStatus.Completed, Description = String.Empty, Value = _interval };
                TwinCollection twin = new TwinCollection();
                twin.Add("interval", targetReport.BuildAcknowledge());
                AzureIoT.UpdateReportedProperties(twin);
            }
        }

        #endregion
        #region Telemetry

        public bool workingSet(double val)
        {
            // This pattern will always work whatever the type of val is including complex objects
            Hashtable report = new Hashtable();
            report.Add("workingSet", val);
            return AzureIoT.SendMessage(JsonConvert.SerializeObject(report));
        }

        #endregion
        #region Commands

        // Those 3 functins are needed for nano for each command to call the delegate, will have to be populated for each command
        public delegate diagnosticResults CommandgetRuntimeStats(int rid, diagnosticsMode diagnosticsMode);

        public void RegisterCommandgetRuntimeStats(CommandgetRuntimeStats commandgetRuntimeStats) => _commandgetRuntimeStats = commandgetRuntimeStats;

        public void UnregisterCommandgetRuntimeStats() => _commandgetRuntimeStats = null;

        #endregion
    }
}
